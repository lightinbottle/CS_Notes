## 基础知识

* MySQL引擎

  MyISAM 和 InnoDB 

* MyISAM

  * **不支持行锁(MyISAM只有表锁)**，读取时对需要读到的所有表加锁，写入时则对表加排他锁；
  * **不支持事务**
  * **不支持外键**
  * **不支持崩溃后的安全恢复**
  * 在表有读取查询的同时，支持往表中插入新纪录
  * 支持BLOB和TEXT的前500个字符索引，**支持全文索引**
  * **支持延迟更新索引**，极大地提升了写入性能
  * 对于不会进行修改的表，支持 **压缩表** ，极大地减少了磁盘空间的占用
  * **不支持在线热备份**

* InnoDB

  - **支持行锁**，采用MVCC来支持高并发，有可能死锁
  - **支持事务、回滚**
  - **支持外键**
  - **支持崩溃后的安全恢复（crash-safe）**
  - **支持在线热备份**

* 两种引擎的使用场景

  * MyISAM 

    锁级别为表锁，表锁优点是开销小，加锁快；缺点是锁粒度大，发生锁冲动概率较高，容纳并发能力低，这个引擎适合**查询为主的业务**。

    MyISAM强调了**快速读取**操作。它**存储表的行数**，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。

  * InnoDB

    锁级别为行锁，行锁优点是适用于高并发的频繁表修改，高并发是性能优于 MyISAM ,适合**密集写的场景**

* Mysql的行锁和表锁

  （ 锁是计算机协调多个进程或纯线程并发访问某一资源的机制） **表级锁：** 每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； **行级锁：** 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高

* MySQL数据类型

  FLOAT四字节 DOUBLE八字节

  CHAR字符串 VARCHAR可变长字符串

* 一条MySQL语句的执行过程

  <center><img src="../Pics/sql语句的执行过程.png" width="70%" height="60%" /></center>

* 查询缓存

  查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的的查询缓存都会被清空。

* 日志

  MySQL日志分为 redo log（重做日志）和binlog(归档日志)

* Redo log

  MySQL中使用WAL（write-ahead logging）技术，对于一个更新操作，InnoDB先把这个更新记录写到内存里，然后更新数据库的值，同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘上。

  InnoDB的redo log是固定大小的，可以分配四个文件，每个文件1G，共4G，结构类似于一个**环形队列**，有两个指针，一个**write pos**写入redo log的指针，一个**check point**是从redo log写入到磁盘的指针

  有了 redo log，InnoDB 就可以实现**crash-safe 崩溃恢复**

* binlog

  redo log是引擎层的日志,而且是InnoDB独有的，  binlog是server层的日志，所有引擎都可以使用

* 两个日志的区别

  * redo log是引擎层的日志,而且是InnoDB独有的，  binlog是server层的日志，所有引擎都可以使用
  * redo log是物理日志 binlog是逻辑日志
  * redolog是循环写 binlog是追加写

* redo log的两阶段提交

  <center><img src="../Pics/事务的两阶段提交.png" width="70%" height="60%" /></center>

  简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。 

## 事务

* 事务就是要保证**一组数据库操作**，要么全部成功，要么全部失败。它是由引擎层实现的
* 事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。
  - **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
  - **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
  - **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
  - **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
* 命令行模式下mysql命令默认是自动提交的
* 事务控制语句
  * **BEGIN** 开始一个事务
  * **ROLLBACK** 事务回滚
  * **COMMIT** 事务确认
* 事务的几个隔离级别
  * 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看得到\

    会产生**脏读**的问题

  * 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。

    会产生**不可重复读**，oracle默认的隔离级别

  * 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 

    产生**幻读**，mysql默认的隔离级别

    通过**多版本并发控制（MVCC**）+ **间隙锁**（Next-Key Locking）防止幻读。 

  * 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 

## 索引

* 索引是为了提高数据库的搜索性能

* MySQL中的索引分类，主键索引、普通索引、唯一索引（值必须唯一）、全文索引（文本全文索引）

* 二叉树搜索性能很高，但是大多数数据库索引结构并不是二叉树，是因为数据库存在磁盘中，二叉树的高度大，这样就要访问磁盘多次，造成很大的延时。所以正常采用N叉树

* InnoDB使用B+树的索引结构

  如我们有一个表，主键是key,表中有字段k，在k上也建立索引

  表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。 

  <center><img src="../Pics/索引结构示例.png" width="70%" height="60%" /></center>

  InnoDB索引分为主键索引和非主键索引

  主键索引中叶子结点保存的是整行的数据，非主键索引中叶子结点保存的是对应的主键的值

  在InnoDB里，主键索引也被称为**聚簇索引**，非主键索引也被称为**二级索引**

  也就是说，基于非主键索引的查询需要多扫描一棵索引树（**先找到主键值，再到主键索引树中查找行数据**）。因此，我们在应用中应该**尽量使用主键查询**。 

  回到主键索引树进行搜索的过程，叫**回表**

* B+树和B树相比的优势：

  * 单一节点存储更多的元素（非叶子节点不存储数据，只做索引），使得查询的IO次数更少；
  * 所有查询都要查找到叶子节点，查询性能稳定，而B树查询性能不稳定，因为可能没有查询到叶子结点就结束查询了；
  * 所有叶子节点形成有序链表，便于范围查询。 支持叶子结点的有序访问

* 联合索引

  * 覆盖索引： 如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作 
  * 最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符 （联合索引的原理就是多个字段拼接在一起，先按照最左的字段排序，然后按右边的字段排序）
  * 联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。 
  * 索引下推：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度 

* MySQL的优缺点

  * 优点：
    * 加快数据库搜索速度，
    * 帮助服务器避免进行排序和分组，以及避免创建临时表 （mysql的索引是有序的）
    * 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）
  * 创建索引，维护索引（修改数据库的值可能会引发动态修改索引树）成本很高
  * 索引需要占用物理空间

* 适合添加索引的场景

  * 在经常需要搜索的列上，加快搜索速度
  * 经常用在连接的键上，主要是一些外键，加快连接的速度
  * 在经常需要进行范围搜索（排序）的列上，因为索引已经排序好

* MySQL为什么使用B+树作为索引结构

  因为数据库数据存储在磁盘中，不可能将整个索引都加载到内存中，那么最差的情况下，对一个记录的搜索次数就是树的高度。所以使用B/B+树能够减少数据库查找过程中磁盘IO的读写次数。

  **而且**，B+树的非叶子结点并不存储数据，只保存关键字作为索引，所以一次性读入的关键字就更多，减少了磁盘IO的读次数

  **那为什么用B+树而不是B树呢？**

  * B+树非叶子结点并不存储数据，只保存关键字作为索引，所以一次性读入内存的关键字就越多，减少了IO操作。
  * B+树非叶子节点不存储数据，所以他的查询性能更稳定（所有的查找都要到树最底部）
  * B+树所有存储数据的叶子结点是顺序相连的，是一个有序的链表，所以顺序访问和范围查找更有优势

* 如果数据都在内存中，二叉树不一定比B+、B树慢，这根B+树是几叉有关，所以之所以用B+树完全是因为可以减少磁盘的IO操作

## 锁

* 加锁是为了并发访问，MySQL中的锁主要分为：**全局锁、表级锁、行级锁**

* 全局锁：全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。 

  全局锁的典型使用场景是**全库逻辑备份**，但是用全局锁进行逻辑备份，会阻塞对数据库的更新等操作

  官方自带的逻辑备份工具是**mysqldump**,当使用参数**-single-transaction**时，导出数据之前，会确保拿到数据库的一致性视图（通过事务隔离级别中的 可重复读级别实现），**-single-transaction**只适用于所有的表都使用事务引擎（都使用InnoDB引擎）的数据库

* 表级锁 

  表级锁分为两种，**表锁**和**元数据锁（meta data lock, MDL）**

  表锁一般是当数据库不支持行锁的情况下使用,如使用的是MyISAM的引擎

  MDL 不需要显示的调用，当访问一个表的时候会被自动的加上，保证读写的正确性（读写过程中，表的结构不会被修改）

  当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁 

  MDL只有等到**事务结束**才会被释放

* 行锁

  行锁是为了提高数据库的并发度

  * 两阶段锁

    在 InnoDB 事务中，**行锁是在需要的时候才加上的**，但并不是不需要了就立刻释放，而是要**等到事务结束时才释放**。这个就是**两阶段锁协议**。 

    所以：如果一个事务中需要对多个行加行锁，那么要把最有可能造成锁冲突、最有可能影响并发度的锁尽量往后放，这样对应的行锁时间就会短一些，减少对并发度的影响。

  行锁容易造成**死锁**

  比如下图所示：

  <center><img src="../Pics/行锁死锁.jpg" width="70%" height="60%" /></center>

  

事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁

* 发生死锁的两种解决方法：
  * **超时退出**： 第一个被锁住的线程超过时间阈值（默认50s）后退出
  * **死锁检测**：发现死锁以后，主动对死锁链路中的一个事务进行回滚，让其他的事务继续执行。
  * 死锁检测会消耗cpu资源
* 减少死锁的做法： 控制并发度，将一行改成逻辑上的多行（减少行锁冲突）

## 主从复制

主从复制涉及三个线程：binlog线程，IO线程，SQL线程

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中执行。

主要用来实现双机热备份，读写分离

## 读写分离

主服务**器处理写操作**以及**实时性要求比较高的读操作**，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度**缓解了锁的争用**；
- 从服务器可以使用 MyISAM，**提升查询性能**以及节约系统开销；
- **增加冗余**，提高可用性。

读写分离常用**代理**方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

## 优化

* 减少请求的数据量，避免使用select * ,可以使用limit来限制返回的行数
* 使用缓存来缓存一些重复查询的数据
* 切分大的查询，大范围的查询会锁上很多的数据，阻塞其他的操作。

## 数据库的三个日志

* binary log是server层的日志，记录每一个数据库操作，是操作日志；

  数据库主从备份里面使用

* redo log（重做日志）和undo log(回滚日志)，都是数据引擎层的日志

* redo log通常是**物理日志**，记录的是**内存页的物理修改**，而不是某一行或某几行修改成怎样，它用来**恢复提交后的物理数据页**(恢复数据页，且只能恢复到最后一次提交的位置)。

* redo log和undo log一般用来作为崩溃后的恢复功能

## 数据库隔离级别的实现



